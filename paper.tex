% tADRguide.tex
% v1.0 released January 2013

\documentclass{tADR2e}

% The following packages can be found on http:\\www.ctan.org
\usepackage{caption}
\usepackage{color}
\usepackage{graphicx} % for pdf, bitmapped graphics files
%\usepackage{epsfig} % for postscript graphics files
\usepackage{mathptmx} % assumes new font selection scheme installed
%\usepackage{times} % assumes new font selection scheme installed
\usepackage{amsmath} % assumes amsmath package installed
\usepackage{amssymb}  % assumes amsmath package installed
\usepackage{mathrsfs}
\DeclareMathOperator*{\argmin}{argmin}
\usepackage{algorithm}
\usepackage{algpseudocode}  %\usepackage[noend]{algpseudocode}
\algtext*{EndWhile}% Remove "end while" text
\algtext*{EndIf}% Remove "end if" text
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{proof}
\newtheorem{property}{Property}
\usepackage[numbers]{natbib}

\makeatletter
%\let\NAT@parse\undefined % allow hyperref to work with ieeeconf.cls for bib numbers
\makeatother
\usepackage{hyperref}
%\usepackage{cite}


% Math shortcuts :
\newcommand\real{\mathbb{R}}
\newcommand\p{\mathbf{p}}
\newcommand\pii{\mathbf{p_{i,i+1}}}
\newcommand\pij{\mathbf{p_{i,j}}}
\newcommand\gT{\tilde{g}^T}
\newcommand\g{\tilde{g}}
\newcommand\CS{\mathcal{C}}
\newcommand\dimCS{n_\mathbf{C}}
\newcommand\body{{\cal B}}
\newcommand\Sone{\mathbf{S}^1}
\newcommand\Sthree{\mathbf{S}^3}
\newcommand\conf{\mathbf{q}}
\newcommand\xx{\mathbf{x}}
\newcommand\cost{C}
\newcommand\weight{W}
\newcommand\translation{\mathbf{t}}
\newcommand\tcolli{t_{coll\ i}}
\newcommand\po{\mathbf{po}}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\begin{document}
\graphicspath{{images/}}

\jvol{00} \jnum{00} \jyear{2015} \jmonth{October}

\title{{\itshape Advanced Robotics} A simple path optimization method for motion planning }	

\author{Myl\`{e}ne Campana$^{a,b}$ $^{\ast}$ \thanks{$^\ast$Corresponding author. Email: mcampana@laas.fr}, Florent Lamiraux$^{a,b}$ and Jean-Paul Laumond$^{a,b}$
\\\vspace{6pt}
$^{a}${\em{LAAS-CNRS, Toulouse, France}};
$^{b}${\em{ This work has been supported by the project ERC Advanced Grant 340050 Actanthrope and by the FP~7 project Factory in a Day under grant agreement n°~609206 }}
}
\maketitle

\begin{abstract}
Most algorithms in probabilistic sampling-based path planning compute 
collision-free paths made of straight line segments lying in the configuration 
space. Due
to the randomness of sampling, the paths make detours that need to be optimized.
The contribution of this paper is to propose a gradient-based (GB) algorithm that
transforms a polygonal collision-free path into a shorter one, while both:
\begin{itemize}
\item requiring mainly collision checking, and few time-consuming obstacle 
distance computation,
\item constraining only part of the configuration variables that may cause a 
collision, and not the entire configurations, and
\item reducing parasite motions that are not useful for the problem resolution.
\end{itemize}
The algorithm is simple and requires few parameter tuning. Experimental
results include navigation and manipulation tasks, e.g. an robotic arm 
manipulating throw a window and a PR2 robot working in a kitchen environment, 
and comparisons with a random shortcut optimizer.

\medskip

\begin{keywords}path optimization; motion planning; robotics
\end{keywords}\medskip

\end{abstract}


\section{Introduction}

Motion planning for systems in cluttered environments has been addressed for more
than thirty years~\citep{ref-motionplan},~\citep{ref-pianomover}. Most planners
today randomly sample the system configuration space~\cite{ref-spaceconfig} in
order to find a collision-free path. The main issue using these techniques is
 that the computed path makes unnecessary detours and needs to be post-processed 
 before being executed by a virtual or real robot. Alternative
strategies exist however.
\begin{itemize}
\item Planning by path-optimization~\cite{itomp2012},~\cite{voronoiOMP} where
obstacle avoidance is handled by constraints or cost using computation of the
nearest obstacle distance. Most of these planners are using non-linear
optimization~\cite{BettsNonlinopt} under constraints.
   
Such planners provide close-to-optimality paths and have smaller time computation
for easy problems, but they are mostly unable to solve narrow passage issues.
 
\item Optimal random sampling~\cite{KaramanPRMstarRRTstar} are also close to an
optimal solution, but computation time is significantly higher than classical
approaches. Moreover the roadmap is only valid for a given motion planning
   problem. 
\end{itemize}

In this paper, we propose a method aimed at shortening path length after a path
planning step. Note that we do not address path planning, but that we take the
result of a probabilistic motion planner as the input to our path optimization 
method.

For this shortening purpose, random shortcut (RS) methods are
still very 
popular~\cite{Sekhavat-Svestka1998,Geraerts04clearancebased,HauserFastSmooth}. 
However, RS requires fine 
tuning of the termination condition (see 
Algorithm~\ref{algo:random-shortcut}) and is no efficient due to randomness for long 
trajectories where only a small part needs to be optimized. 
Figure~\ref{decoupled_DOF_optimization} presents another situation where RS will 
always fail to optimize the initial path, since it cannot decouple the 
robot degrees of freedom (DOF) on which the optimization occurs, contrary to our 
algorithm or partial random shortcut (PRS) methods~\cite{Geraerts04clearancebased} 
that shortcut only one or a group of DOF.

\begin{figure}[H]
	\centering
	\includegraphics[width=7.5cm]{decoupled_DOF_optimization.pdf}
	\caption{Example of a path which random shortcut will never manage to 
	optimize: each shortcut tentative will provide a collision or will not 
	decrease the path length. The optimal path belongs to the $x-y$ plane 
	containing $q_{init}$ and $q_{end}$.}
	\label{decoupled_DOF_optimization}
\end{figure}


On the other hand, numerical
optimization methods like CHOMP~\cite{RatliffChomp} can be used as a
post-processing step. They have clear termination conditions, but collision
avoidance is handled by inequality constraints sampled at many points along
the trajectory. These methods therefore require a pre-processing step of the
robot (and/or environment) model in order to make 
it simpler:~\cite{RatliffChomp} covers PR2 bodies with spheres, 
while~\cite{convexOptimMotplan} needs to decompose objects into convex subsets.
Moreover, in the applications we address, optimality is not desirable as
such since the shortest path between two configurations in a cluttered
environment usually contains contacts with the obstacle,
or is most of the time
out of the scope of numerical optimization algorithms~\cite{LaumondOptim}.

The idea of our method is to find a good trade-off between
the simplicity of “blind” methods like shortcut algorithm,
and the complexity of distance based optimization techniques.
The method iteratively shortens the initial path with gradient-based information.
When a collision is detected at a given iteration, the method backtracks to the
latest valid iteration and inserts a one-dimensional constraint
between the objects detected in collision. Only collisions between objects are 
evaluated, therefore no pre-processing of the
robot or environment models is necessary to increase distance computation speed. 
Preserving the problem geometry also 
guarantees that a solution can still be found, e.g. for narrow passages as holes or 
grippers. The underlying optimization algorithm is a quadratic program.

Related work is presented in Section II. Section III explains how the 
path-optimizer works, from the formulation of the problem to the implemented
algorithm. Finally, we conclude on experimental results in Section IV.


????? This paper is based on a similar work, which has been sent to ICRA, with a different type of collision constraints.


\section{RELATED WORK}

CHOMP algorithm~\cite{RatliffChomp} optimizes an initial guess provided as
input. It minimizes a time invariant cost function using efficient covariant
hamiltonian gradient descent. The cost is quantified by non-smooth parts (with
high velocities) and an obstacle avoidance term, provided by the distance to the 
nearest obstacle for each iteration of the trajectory. Calculating these nearest 
distances however is time-consuming because the distances between all pairs of 
objects must be computed at each time step along the path. To reduce the 
computation time, the method starts by building offline a map of distances that 
will be called during the optimization at the requested time. Besides, meshes 
are pre-processed into bounding spheres so that distances are computed faster 
at the cost of a geometry approximation.

STOMP method~\cite{KalakrishnanStomp} avoids to compute an 
explicit gradient for cost optimization using a stochastic analysis of local 
random samples. But as for CHOMP, the obstacle cost term requires a voxel map to 
perform its Euclidian Distance Transforms, and represents the robot bodies with 
overlapping spheres. Such technique provides lots of distance and penetration 
information but remains very time consuming and is not as precise as some 
distance computation techniques based on the problem meshes as 
Gilbert-Johnson-Keerthi~\cite{gilbertGjk}.

Some optimization-based planners may not require an initial guess but some naive 
straight-line manually or randomly-sampled initialization as 
TrajOp~\cite{SchulmanConvexOptim}. Its trajectory is iteratively optimized with 
sequential convex optimization by minimizing at each step its square length, 
linear and non-linear constraints considered as penalties. To compute the 
collision-constraints, nearest obstacle distances are calculated at each discrete 
time of the trajectory vector. This can be a burden for a high-dimensional robot 
or a complex environment as we propose to use, and may be compensated with a 
short path composed of only one or two waypoints.


The elastic strips framework~\cite{BrockElasticStrips} is also an optimization 
based method. The path is modeled as a spring and obstacles give rise to a 
repulsive potential field. Although designed for on-line control purposes, this 
method may be used for path shortening. In this case however, the number of 
distance computation is very high. The authors also proposed to approximate the 
robot geometry by spheres.

Some heuristics use random shortcuts on the initial guess combined with a 
trajectory re-building that returns ${C}^1$ shortcuts made of parabolas and lines 
(bang-bang control)~\cite{HauserFastSmooth}. These local refined trajectories 
are time-optimal since they comply with acceleration and velocity constraints. 
~\cite{Guernane2011}, also based on random shooting, is guiding configuration-
generation with local holonimic considerations. But this method remains only locally 
optimal, and is not addressing high-DOF problems.
~\cite{Geraerts04clearancebased}, whereas just implemented for freeflyer robots, is 
using medial axis retractation for clearance and a PRS (applied only on random DOF) 
which can address the problem of Figure~\ref{decoupled_DOF_optimization} but is 
relatively slower than RS. Moreover, PRS is not using the information returned by 
the checker of which links are colliding to guide which DOF or group of DOF are 
relevant to shortcut, contrary to our method.

In some way, our method shares similarities with~\cite{PanSmoothSplineShort} 
since this latter method relies on collision checking and backtracks when an 
iteration is detected in collision, instead of trying to constantly satisfy 
distance constraints. Unlike our method however, interpolating configuration -which 
can be viewed as constraints- are freezing the whole robot configuration instead of 
a relevant subpart. Thus, this method cannot solve the 
Figure~\ref{decoupled_DOF_optimization} problem.

%Unlike our method however, the iterations are composed of 
%Cubic-B-splines. The benefit of this method is that the result is a 
%differentiable path.



\section{PATH OPTIMIZATION} \label{section:path_optim}

\subsection {Kinematic chain}

A robot is defined by a kinematic chain composed of a tree of joints. We denote 
by $(J_1,\cdots,J_m)$ the ordered list of joints. Each joint $J_i$, $1\leq i\leq 
m$ is represented by a mapping from a sub-manifold of $\real^{n_i}$, where $n_i$ 
is the dimension of $J_i$ in the configuration space, to the space 
of rigid-body motions $SE(3)$. The rigid-body motion is the position of the joint 
in the frame of its parent. In the examples shown in this paper, we consider 4 
types of joints described in Table~\ref{tab:joints}.
\begin{table}[b]
\centerline {
  \begin{tabular}{cccc}
    Name & dimension & config space & velocity\\
    \hline
    translation & 1 & $\real$ & $\real$\\
    bounded rotation & 1& $\real$ & $\real$\\
    unbounded rotation & 2 & $\Sone\subset\real^2$ & $\real$\\
    $SO(3)$ & 4 & $\Sthree\subset\real^4$ & $\real^3$
  \end{tabular}
}
\caption {Translation and rotation joint position are defined by 1 
parameter corresponding respectively to the translation along an axis and a 
rotation angle around an axis. Unbounded rotation is defined by a point on the 
unit circle of the plane: 2 parameters corresponding to the cosine and the 
sine of the rotation angle. $SO(3)$ is defined by a unit quaternion. The 
velocity of translation and unbounded rotation joints is the derivative of the 
configuration variable. The velocity of an unbounded rotation joint corresponds 
to the angular velocity. The velocity of a $SO(3)$ joint is defined by the 
angular velocity vector $\omega\in\real^3$.}
\label{tab:joints}
\end{table}
A configuration of the robot
$$\conf = (\underbrace{q_1,\cdots,q_{n_1}}_{J_1},\underbrace{q_{n_1+1},
\cdots,q_{n_1+n_2}}_{J_2},\cdots q_n),\ n\triangleq\sum_{i=1}^m n_i$$
is defined by the concatenation of the joint configurations. The configuration 
space of the robot is denoted by $\CS\subset\real^n$.

Note that the configuration of the robot belongs to a sub-manifold of $\real^n$.

The velocity of each joint $J_i$, $1\leq i \leq m$ is defined by a vector of $
\real^{p_i}$, where $p_i$ is the number of DOF of $J_i$. Note that 
the velocity vector does not necessarily have the same dimension as the 
configuration vector.

The velocity of the robot is defined as the concatenation of the velocities of 
each joint.
$$\dot{\conf} = (\underbrace{\dot{q}_{1},\cdots,\dot{q}_{p_1}}_{J_1},
\underbrace{\dot{q}_{p_1+1},\cdots,\dot{q}_{p_1+p_2}}_{J_2},\cdots \dot{q}_p),\ p
\triangleq\sum_{i=1}^m p_i$$

\paragraph {Operations on configurations and vectors} by analogy with the case 
where the configuration space is a vector space, we define the following 
operators between configurations and vectors:
$$
\conf_2 - \conf_1 \in \real^p, \ \conf_1, \conf_2\in\CS
$$
is the constant velocity moving from $\conf_1$ to $\conf_2$ in unit time, and
$$
\conf + \dot{\conf}\in\CS, \ \conf\in\CS \ \dot{\conf}\in\real^p
$$
is the configuration reached from $\conf$ after following constant velocity $
\dot{\conf}$ during unit time.

Note that the definitions above stem from the Riemanian structure of the 
configuration space of the robot. The above sum corresponds to the exponential 
map. We do not have enough space in this paper to develop the theory in a more 
rigorous way. The reader can easily state that ``following a 
constant velocity'' makes sense for the four types of joints defined in 
Table~\ref{tab:joints}. We refer to~\cite{riemanian-optim2008} Chapter~5 for 
details about Riemanian geometry.

\subsection {Straight interpolation}

Let $\conf_1, \conf_2\in\CS$ be two configurations. We define the straight 
interpolation between $\conf_1$ and $\conf_2$ as the curve in $\CS$ defined on 
interval $[0,1]$ by:
$$
t \rightarrow \conf_1 + t (\conf_2 - \conf_1)
$$
This interpolation corresponds to the linear interpolation for translation and 
bounded rotations, to the shortest arc on $\Sone$ for unbounded rotation and to 
the so called slerp interpolation for $SO(3)$.

\subsection{Problem definition}

We consider as input a path composed of a concatenation of straight 
interpolations between $wp+2$ configurations: $(\conf_0, \conf_1,\cdots,\conf_{wp
+1})$. This path is the output of a random sampling path planning algorithm 
between $\conf_0$ and $\conf_{wp+1}$. We wish to find a sequence of waypoints $
\conf_{1}$,...,$\conf_{wp}$ such that the new path $(\conf_0, \conf_1,\cdots,
\conf_{wp+1})$ is shorter and collision-free. Note that $\conf_0$ and $\conf_{wp
+1}$ are unchanged and that the workspace of the robot contains obstacles. We 
denote by $\xx$ the optimization variable:
$$
\xx \triangleq (\conf_1,\cdots,\conf_{wp})
$$

\subsubsection {Cost}

let $W\in\real^{p\times p}$ be a diagonal matrix of weights:
$$
W=\left(\begin{array}{cccccccccc}
w_1 I_{p_1}       &        &  0  \\
    & w_2 I_{p_2} &        &   \\
    &            & \ddots &   \\
  0 &            &        & w_m I_{p_m}
\end{array}\right)
$$
where $I_{p_i}$ is the identity matrix of size $p_i$ and $w_i$ is the weight 
associated to the lever arm of the joint $J_i$. We define the length of the straight interpolation 
between two configurations as:
$$
\|\conf_2 - \conf_1\|_{W} \triangleq \sqrt{(\conf_2 - \conf_1)^T W^2 (\conf_2 - 
\conf_1)}.
$$
Weights are used to homogenize translations and rotations in the velocity vector. 
For rotations, the weight is equal to the maximal distance of the robot bodies 
moved by the joint to the center of the joint.

Given $\conf_0$ and $\conf_{wp+1}$ fixed, the cost we want to minimize is defined 
by
$$
\cost (\xx) \triangleq \frac{1}{2}\sum_{i=1}^{wp+1} \lambda_{i-1} \|\conf_{i}-\conf_{i-1}\|_{W}
^{2}
$$
where the $\lambda_{i-1}$ coefficients benefit will be explained in the results 
section. For now we can assume that $\forall i,\, \lambda_{i-1}=1$.

Note that $\cost$ is not exactly the length of the path, but it can be 
established that minimal length paths also minimize $\cost$. This latter cost is 
better conditioned for optimization purposes.

\subsection {Resolution}
We assume that the direct interpolation between the initial and final configurations contains collisions.
Let $H$ denotes the constant Hessian of the cost function, an iteration is 
described as follow:
\begin{equation}\label{eq:iteration-1}
\begin{split}
& \pii =  -H^{-1} \nabla c(\xx_i)^{T} \\
& \xx_{i+1} =  \xx_{i} + \alpha_i \pii
\end{split} 
\end{equation}
where $\alpha_i$ is a real valued parameter. Taking $\alpha_i=1$ yields the 
unconstrained minimal cost path, i.e. all waypoints aligned on the straight line 
between $q_0$ and $q_{n+1}$. Since this solution is in collision, we set 
$\alpha_i = \alpha$ 
where $\alpha$ is a parameter that will be explained in the algorithm section.

We iterate step~(\ref{eq:iteration-1}) until path $\xx_{i+1}$ is in collision. This 
corresponds to the unconstrained function \texttt{computeIterate} in 
Algorithm~\ref{algo:gradient}.
When a collision is detected, we introduce a constraint and perform a new 
iteration from $\xx_i$ as explained in the next section. We use a continuous 
collision checker inspired of~\cite{SchwarzerExactCollision} to validate our 
paths and to return the first colliding configuration along a path. This step corresponds to \texttt{validatePath} in Algorithm~\ref{algo:gradient}.

\subsection{Constraints}

\begin{figure}[t]
	\centering
	\includegraphics[width=9cm]{optim_grad.pdf}
	\caption{Illustration of one iteration of our optimization. $\xx_{i+1}$ 
	appears 
	to be in collision with the obstacle, the first colliding configuration 
	$\xx_{i+1}(\tcolli)$ is returned by the continuous collision checker. The corresponding constraint will be computed in configuration $\xx_{i}(\tcolli)$.}
	\label{optim_grad}
\end{figure}

Let $T$ be a positive real number such that each path $\xx_i$ is a mapping from 
interval $[0,T]$ into $\CS$: $\xx_i(0) = q_0$, $\xx_i(T) = q_{n+1}$ for all $i$. Let 
us denote by $\tcolli$ the abscissa of the first collision detected on path 
$\xx_{i+1}$, which previous iteration $\xx_i$ was collision-free (see 
Figure~\ref{optim_grad}). Thus in 
configuration $\xx_{i+1}(\tcolli)$ a collision has been 
detected. Two cases are possible:
\begin{enumerate}
\item the collision occurred between two bodies of the robot: $\body_1$ and $
\body_2$, or
\item the collision occurred between a body of the robot $\body_1$ and the 
environment.
\end{enumerate}
In the rest of this section, we will only consider the first case. Reasoning 
about the second case is similar, except that the 
constraint is on the position of $\body_1$ with respect to the environment.

\begin{figure}[b]
	\centering
	\includegraphics[width=15cm]{contact-points.pdf}
	\caption{Bodies representation in collision-configuration (left) and 
	backtracked free-configuration (right). A contact point (i.e. any point in 
	the intersection of the bodies) $\po_c$ can be returned by the Flexible 
	Collision Library~\cite{fcl}, used to detect collisions. The red $(\perp)$ 
	line is orthogonal to ($\po_2$,$\mathbf{u}$) and represents the motion 
	direction which is allowed by the constraint.}
	\label{contact-points}
\end{figure}

The principle of the method is to compute a constraint on the backtracked free-
configuration $\xx_{i}(\tcolli)$ to avoid the encountered collision $\xx_{i+1}
(\tcolli)$. To handle this, we introduce a one-dimensional constraint based on the 
orthogonal direction of the encountered collision.

In the collision-configuration $\xx_{i+1}(\tcolli)$, let $\po_c\in \real^3$ be a 
contact point expressed in the global frame ${\cal R}_0$ of each of the two 
bodies (Figure~\ref{contact-points} left). We compute the associated points $\po_1$ 
and $\po_2$ in the free-configuration $\xx_{i}(\tcolli)$, and the difference 
$\mathbf{u}=\po_2-\po_1$ which will be used as the orthogonal direction the 
bodies can not move along at the path parameter $\tcolli$ 
(Figure~\ref{contact-points} right).


%Let $\translation^{*}\in \real^3$ denotes the position between frames of $
%\body_1$  and $\body_2$ in configuration $\xx_i(\tcolli)$. Let $\translation \in 
%\real^3$ (resp. $R\in SO(3)$) denote the same position (resp. rotation) in 
%configuration $\xx (\tcolli)$ where $\xx$ is any path in $\CS^{wp}$.

Let $M^{*}\in SE(3)$ denote the homogeneous transformation between frames of $
\body_1$  and $\body_2$ in configuration 
$\xx_i(\tcolli)$. Let $M\in SE(3)$ denote the same transformation in configuration 
$\xx (\tcolli)$ where $\xx$ is any path 
in $\CS^{wp}$. Let $R\in SO(3)$ and $\translation\in\real^3$ 
(resp. $\translation^{*}$) be the rotation 
and translation parts of $M$ (resp. $M^{*}$).

We denote by $F$ the path constraint defined by the mapping from $\CS^{wp}$ to $
\real^3$ defined by
\begin{equation}\label{eq:constraint}
F (\xx) =  \mathbf{u}^T R^T (\translation^{*} - \translation)
\end{equation}
where the product $R^T (\translation^{*} - \translation)$ is used to express the translations difference in the global frame ${\cal R}_0$.

Note that $F$ vanishes for any path $\xx$ such that in configuration
$\xx(\tcolli)$ the relative position of $\body_2$ w.r.t. $\body_1$ is equal to $
\translation^{*}$ or if the relative position $\translation^{*} - \translation$ is orthogonal to $\mathbf{u}$.


When a collision is detected at $\tcolli$ along path $\xx_{i+1}$, we wish to add
constraint
\begin{equation}\label{eq:non-linear constraint}
F (\xx) = 0
\end{equation}
However, as this constraint is non-linear, we linearize it around $\xx_i$:
$$
\frac{\partial F}{\partial \xx}(\xx_i)(\xx -\xx_i) = 0
$$
for any later iteration $\xx_j$, $j\geq i+1$. Both $F$ and $\frac{\partial F}{\partial \conf}$ are provided by our path planning framework~\cite{hpp} as differentiable functions.

\vspace{0.2cm}

Let $q_{k\,i}$ denote the waypoint $k$ along path $x_i$.
The constraint on the position at $t_{coll\,i}$ is a function that depends only
on two waypoints $q_{k\,i}$, $q_{k+1\,i}$, with $0\leq k\leq n$. There exists 
$\beta\in[0,1]$ such that for any $j$:
$$
\xx_j (t_{coll\,i}) = \conf_{k\,j} + \beta (\conf_{k+1\,j} - \conf_{k\,j})
$$
The path Jacobian $J_F$ of constraint~(\ref{eq:constraint}) w.r.t. $x$ is thus built by block using the previous constraint jacobian $\frac{\partial F}{\partial \conf}$ and $\beta$. ????
%Therefore, the Jacobian $J_F$ of constraint~(\ref{eq:constraint}) with respect to 
%$x$ is
%$$
%J_F = \left(\begin{array}{cccccc}
%0 & \cdots & (1-\beta)\,\mathbf{u}^T \frac{\partial F}{\partial q} (\xx_j(t_{coll\,i})) & \
%\beta\,\mathbf{u}^T \frac{\partial F}{\partial q} (\xx_j(t_{coll\,i})) & \cdots & 0
%\end{array}
%\right)
%$$


\vspace{0.2cm}

Each time a new constraint is added to the resolution, we stack its jacobian $J_F$ to the previous ones. This corresponds to \texttt{addCollisionConstraints} in 
Algorithm~\ref{algo:gradient}. Then we refer to~\cite{nocedal2006numerical} for solving constrained quadratic programs (QP) (function \texttt{computeIterate} in 
Algorithm~\ref{algo:gradient}).

%The solution step is given by:
%$$
%\mathbf{\pii}^{*} = -V_0(V_0^TH V_0)^{-1}\,V_0^T\nabla c(\xx_i)
%$$
%where $V_0$ is the base of the nullspace of the stack of $J_F$ jacobians.


\subsection{Algorithm}

In this part we describe the GB path-optimizer Algorithm~\ref{algo:gradient} 
according to the previous step definitions. The main difficulty here is to handle 
the scalar parameter $\alpha$ determining how much of the computed step $\p$ will 
be traveled through, and also to return a collision-free path. Typically, we 
chose $\alpha_{init} = 0.2$ to process small steps. $\alpha_{init} = 0.5$ is more 
encountered in the optimization literature, procuring larger steps but with more 
risks of collision.

\begin{algorithm}
\begin{algorithmic}%[1] % line numerotation
\Procedure{Optimize}{$\xx_0$}
	\State $\alpha \gets \alpha_{init}$
	\State $minReached \gets false$
	\While{($\textbf{not}(noCollision \textbf{ and } minReached)$)}
		\State $\p = \texttt{computeIterate}()$
		\State $minReached = (||\p||<10^{-3} \textbf{ or } \alpha=1)$
		\State $\xx_1 \gets \xx_0 + \alpha\,\p$
		\If{(\textbf{not}(\texttt{validatePath($\xx_1$)}))}
			\State $noCollision \gets false$
			\If{$(\alpha \neq 1)$}
				\State \texttt{addCollisionConstraints}()
				\State $\alpha \gets 1$
			\Else
				\State $\alpha \gets \alpha_{init}$
			\EndIf
		\Else
			\State $\xx_0 \gets \xx_1$
			\State $noCollision \gets true$
		\EndIf
	\EndWhile
	\Return $\xx_0$
\EndProcedure
\end{algorithmic}
\caption{Gradient-based (GB) path-optimization.} \label{algo:gradient}
\end{algorithm}

Each time a collision-constraint is added, 
the solution of the current QP is tested (i.e. $\alpha = 1$). If this path is collision-free, the algorithm returns it as the solution. Otherwise, 
smaller steps are iteratively applied and tested toward the minimum, and constraints are added each time a collision is found.


\section{RESULTS}

This part gathers optimization results performed on the planning software 
Humanoid Path Planner~\cite{hpp}. The initial trajectory is obtained with two 
kind of probabilistic planners: Visibility-PRM~\cite{visibility-prm} and 
RRT-connect~\cite{rrt-connect}.

\subsection{From 2D basic examples...}

\begin{figure}[t]
	\centering
	\includegraphics[width=7.8cm]{contact_points6.png}
	%\noindent\rule{8cm}{0.8pt}
	\includegraphics[width=8cm]{contact_points2potential.png}
	\caption{Path-optimization results on 2D-ponctual robots, moving around 
	green obstacles. Initial paths are in red, optimized ones in black. Grey paths 
	represent intermediate iterations, red and black dots resp. $\po_1$ and $\po_2$ 
	points, red segments $\mathbf{u}$ and blue circles collision-free configurations 
	of the backtracked paths 
	where constraints have been computed.}
	\label{2D_long}
\end{figure}

Figure~\ref{2D_long} shows several iterations of our optimizer on 2D cases. Since 
in this special case, orthogonal constraints are equivalent to forbidden motion 
direction, we can verify that our optimized path is applying 
all computed constraints. We can also understand which collisions have led to 
the constraints.

Besides, these examples give a better understanding of how the tuning of $\alpha$ 
has to balance lot of iterations and relevant collision-constraint addition. For 
example, if we alter a lot the initial path with a large gradient step and 
compute the corresponding collisions, constraints will be chosen on a very-not 
optimal path and will not be pertinent w.r.t. the obstacles we wanted to 
avoid.

Figure~\ref{local_box_optim} illustrates a \textit{very long} path example that RS or PRS will not manage to 
optimize in an affordable time, because of probabilistically failing to sample 
configurations in the box. GB succeeds to optimize the 
path contained in the box, with the following cost coefficients 
$$
\lambda_{i-1} = \frac{1}{\sqrt{(\conf_{i\,0}-\conf_{i-1\,0})^T \weight^2 
(\conf_{i\,0}-\conf_{i-1\,0})}}
$$
aiming at keeping the same ratio between path segment lengths at 
minimum as at 
initial path, represented by the waypoints ($\conf_{i\,0})_{1\leq i\leq n+1}$.
Without these coefficients, the path that minimizes the cost corresponds to a 
straight line with the waypoints equidistantly allocated, which is not adapted for 
the Figure~\ref{local_box_optim} type of problems with a local passage very
constrained by obstacles. Note that this cost is also working with all other 
examples presented in this paper.


\begin{figure}[t]
	\centering
	\includegraphics[width=7.5cm]{local_box_optim.png}
	\caption{Case of a long initial path (above) containing a small part that can 
	be optimized (below). Random shortcut is unlikely to optimize the part 
	containing detours in the box, whereas our method 
	succeeds (in blue). This type of issue is common in navigation problems in 
	environments with long corridors.}
	\label{local_box_optim}
\end{figure}



\subsection{To 3D complex problems}

We also experiment our algorithm on more complex robots, with transformation 
collision-constraints. Unless another value is given, $\alpha_{init}$ is set to 0.2.

%\begin{figure}[b]
%	\centering
%	\includegraphics[width=5cm,height=3.5cm]{ur5_v2.png}
%	\caption{6-DOF robot arm on which our path-optimization has been tested.}
%	\label{ur5}
%\end{figure}


\begin{algorithm}
\begin{algorithmic}[1] % line numerotation
\Procedure{randomShortcut}{$\xx$}
   \State nbFailures $\gets 0$
   \While {$nbFailures < maxNbFailures$}
        \State $failure \gets true$
        \State $T \gets \mbox{upper bound of }\xx\mbox{ definition interval}$
        \State $t_1 < t_2 \gets \mbox{random numbers in }[0,T]$
        \State $lp0 \gets \texttt{steeringMethod} (\xx(0), \xx(t_1))$
        \State $lp1 \gets \texttt{steeringMethod} (\xx(t_1), \xx(t_2))$
        \State $lp2 \gets \texttt{steeringMethod} (\xx(t_2), \xx(T))$
        \State $newPath \gets \mbox{empty path defined on }[0,0]$
   	\If{$lp0$ is collision-free}
          \State $newPath \gets lp0$; $failure \gets false$
        \Else
          \State $newPath \gets \xx_{|[0,t_1]}$
        \EndIf
   	\If{$lp1$ is collision-free}
          \State $newPath \gets \texttt{concatenate} (newPath, lp1)$
          \State $failure \gets false$
        \Else
          \State $newPath \gets \texttt{concatenate} (newPath, \xx_{|[t_1,t_2]})$
        \EndIf
   	\If{$lp2$ is collision-free}
          \State $newPath \gets \texttt{concatenate} (newPath, lp2)$
          \State $failure \gets false$
        \Else
          \State $newPath \gets \texttt{concatenate} (newPath, \xx_{|[t_2,T]})$
        \EndIf
        \State $\xx \gets newPath$
        \If {$failure$} $nbFailures \gets nbFailures + 1$
        \EndIf
      \EndWhile
    \Return $\xx$
\EndProcedure
\end{algorithmic}
\caption{Random shortcut as adapted from~\cite{Sekhavat-Svestka1998} 
Section~6.4.1. \texttt{steeringMethod} returns the linear interpolation between 
two configurations. $\xx_{|I}$ denotes path $\xx$ restricted to interval $I$. 
$maxNbFailures$ is a parameter that affects time of computation and quality of 
the result.}\label{algo:random-shortcut}
\end{algorithm}

\begin{figure}[b]
	\centering
	\includegraphics[height=4.9cm,width=1.8cm]{pr2_initial_final_vertical.png}
	\includegraphics[width=5.7cm]{p0_pr2_alone_merged3.png}
	\includegraphics[height=4.9cm]{p1RS_pr2_alone_merged3.png}
	\includegraphics[height=4.9cm]{p1GB_pr2_alone_merged3.png}\\
	\caption{PR2-crossing-arms example. In this motion planning problem, PR2 robot 
	has just to 
exchange the positions of its arms. The task is simple, however, in absence of 
explicit indication, any probabilistic motion planner will compute a path that 
makes the PR2 mobile base purposelessly moving. This is the case of RRT-connect 
algorithm (left). Path optimization is expected to remove unnecessary motions. 
The popular RS algorithm fails in this case (middle). Our GB algorithm 
succeeds (right).}
	\label{pr2_final}
\end{figure}

In the included video, we present multiple situations where the GB algorithm has 
been tested and compared to RS~\cite{randomShortcutHPP}
(Algorithm~\ref{algo:random-shortcut}) and PRS ~\cite{partialrandomShortcutHPP} 
adapted from~\cite{Geraerts04clearancebased}.
The termination condition of RS allows it to try 
shortening the path until 5 iterations of non-improvement are reached 
(corresponding to $maxNbFailures$ in Algorithm~\ref{algo:random-shortcut}).
For PRS, first a shortcut is tried on each DOF between $\conf_0$ and $\conf_{n+1}$. Then, for each DOF, configurations are shot as in Algorithm~\ref{algo:random-shortcut} and the steering-method returns a path made by an interpolation on only the current DOF and the previous subpath for other DOF. If this path is collision-free, it is replaced as in RS. This process is also stopped when 5 iterations of non-improvement are reached.

%But we admit that restrincting the number of random shortcut iterations is 
%neither a acceptable criterion because of randomness.
%We also discuss the good properties and limits of our algorithm.

% analysis UR2:
On the double-arm problem (see Figure~\ref{trajectories} top-right), one arm has to get around an obstacle while the 
other is relatively far from obstacles. As expected, the initial path given by 
RRT-connect activates both arms to solve the problem. Contrary to RS, 
GB manages to cancel the rotation of the free-arm while optimizing the 
first arm motion. Initial path length 5.17 has been decreased to 4.55 by RS and to 3.20 by GB.


\begin{figure}[t]
	\centering
	\includegraphics[width=6cm]{fiad_qinit.png}
	\includegraphics[width=6cm]{fiad_qfinal.png}\\
	\includegraphics[width=6cm]{fiad_real.png}
	\includegraphics[width=6cm]{fiad-trajectorires.png}
	
	\caption{(Bottom left) An industrial use-case example proposed by Philips for 	
	the 
	Factory-in-a-Day project~\cite{factory-day-video}. A similar environment have 
	been created (top) to 
	illustrate that our method can comply with an industrial problem, where 
	initial and final configurations are constrained in boxes. Trajectories results 
	are presented (bottom right).}
	\label{fiad}
\end{figure}

% analysis UR5:
For the following example with a 6-axis manipulator arm (see Figure~\ref{trajectories} bottom-left)
%(Figure~\ref{ur5})
in a  cluttered environment, path reduction only manages to reduce some but not 
all detours. This behavior can be explained by a path over-constraining due to the 
important proximity of the robot to the obstacles during the whole path, and 
because there are not so many DOF to play on to easily avoid collisions and 
return a small-cost solution.
We advance this explanation because on the two following high-DOF examples of the 
video (and Figure~\ref{pr2_final}), results are better 
in terms of path length and quality.



% analysis PR2 alone:
In the example presented Figure~\ref{pr2_final} and in the video, the mobile 
40-DOF PR2 simply has to cross its arms from 
the left arm up position to the right arm up one. Lengths of the initial path, the 
RS optimized path and the GB optimized path are 
respectively 14.5, 6.34 and 3.62. The RRT-connect planner 
returns detours and activates non-useful DOF such as the head, the torso lift 
and the translation on 
the ground. Once again, RS will hardly optimize the mobile base 
translation of the robot and other unnecessary DOF uses, unlike our 
optimized-path which mainly results in moving the arms as expected 
(Figure~\ref{pr2_final} right).
%The removal 
%of the translation is also a consequence of our cost ponderation as described in 
%the previous section.
% NON ???

% analysis PR2 in kitchen:
We obtain similar results on the PR2 performing a manipulation task 
in a kitchen environment (see the video). The robot has to move 
his hands from the top to the bottom of a table.
Our optimizer manages to reduce the initial length 15.8 from the visibility-PRM 
planner and improves the path quality 
just adding transformation constraints between the table and the 
robot's arms and grippers. Thus, the robot just slightly moves 
backward and uses its arm DOF to avoid the table, instead of 
processing a large motion to get away from the table. With GB, the path length is downed to 4.59, against 8.24 for RS.

Optimization computation time and path length averages are presented for 30 runs of 
the PR2-crossing-arms in the Table~\ref{tab:results}. In the same way, time 
computation averages for the PR2-in-kitchen example have been 
calculated: $59.5\,\text{s}$ (GB) and $76.2\,\text{s}$ (RS).
Thus our method presents 
similar computation times and path lengths for mobile manipulation tasks. However, 
the disappearance of the mobile base motion in the gradient-based optimized path is 
shown in the right column of Table~\ref{tab:results}. Thus the problem addressed 
Figure~\ref{decoupled_DOF_optimization} is solved considering this DOF.




\begin{figure}[t]
	\centering
	\includegraphics[width=7.0cm,height=6.8cm]{pr2_orth_constr_results.png}
	\includegraphics[width=7.0cm,height=6.8cm]{ur2_orth_constr_results.png}\\
	\vspace{0.05cm}
	\includegraphics[width=7.0cm,height=6.3cm]{ur5sph_orth_constr_results.png}
	\includegraphics[width=7.0cm,height=6.3cm]{puzzle_orth_constr_results.png}
	\caption{Trajectories of wrists, end-effectors or center allong different paths: the initial path is represented in red, the RS optimized path in blue and the GB optimized path ($\alpha_{init}=0.1$) in green.}
	\label{trajectories}
\end{figure}

Trajectories results of the robots end-effectors or center are presented 
Figure\ref{trajectories}.

DESCRIBE TRAJECTORIES



\begin{table}
\centering
\scalebox{0.9}{
  \begin{tabular}{ccccc}
  \toprule
    \textbf{Problem} & Path obtained from & Computation time  & Path length & Base traveled distance\\
    \midrule
    \midrule
    & Initial &  & $14.3$  &\\
    \textbf{Freeflyer-} & GB & $\,\text{ms}$ & $ $  &\\
    \textbf{puzzle} & PRS & $6.53\,\text{ms}$ & $14.3$  &\\
    & RS & $68.3\,\text{ms}$ & $6.05$  &\\
    \midrule
    & Initial &  & $11.3$  &\\
    \textbf{Double-arm} & GB & $318\,\text{ms}$ & $4.95$  &\\
    \textbf{5-DOF} & PRS & $8.42\,\text{ms}$ & $8.73$  &\\
    & RS & $61.9\,\text{ms}$ & $6.96$  &\\
    \midrule
    & Initial &  & $10.8$  & $8.03$\,\text{m}\\
    \textbf{PR2-crossing-} & GB & $24.8\,\text{s}$ & $1.90$  & $0\,\text{m}$\\
    \textbf{arms} & PRS & $41.1\,\text{s}$ & $ 4.73$ & $0\,\text{m}$\\
    & RS & $31.5\,\text{s}$ & $1.60$ & $2.70\,\text{m}$\\
    \midrule
    & Initial &  & $15.0$ &\\
    \textbf{PR2-in-} & GB & $288\,\text{s}$ & $4.40$ &\\
    \textbf{kitchen} & PRS & $431\,\text{s}$ & $12.1$ &\\
    & RS & $95.6\,\text{s}$ & $5.33$ &\\
    \midrule
    & Initial &  & $ $ &\\
    \textbf{6-DOF-arm-} & GB & $\,\text{s}$ & $ $ &\\
    \textbf{with-spheres} & PRS & $\,\text{s}$ & $ $ &\\
    & RS & $\,\text{s}$ & $ $ &\\
    \midrule
    & Initial &  & $ $ &\\
    \textbf{6-DOF-arm-} & GB & $\,\text{s}$ & $ $ &\\
    \textbf{through-window} & PRS & $\,\text{s}$ & $  $ &\\
    & RS &  $\,\text{s}$ & $ $ &\\
    \midrule
    & Initial &  & $19.0$ &\\
    \textbf{Baxter-in-} & GB & $2449\,\text{s}$ & $5.85$ &\\
    \textbf{office} & PRS & $638\,\text{s}$ & $17.5$ &\\
    & RS & $139\,\text{s}$ & $13.3$ &\\
    \bottomrule
  \end{tabular}
  }%scalebox
\caption{Average results for 30 runs of several examples presented in the paper or 
the video. For each run, a solution path is planned by Visibility-PRM as initial 
guess for each optimizer. $\alpha_{init}$ is set to 0.1.
For the PR2-crossing-arms example only, the right column represents the 
distance that is traveled by the robot mobile base during the different paths.
}
\label{tab:results}
\end{table}



\section{CONCLUSIONS}
We managed to settle a path optimization for decoupled-DOF robots such as mobile 
manipulators. Our algorithm uses standard numerical tools as collision checking 
and QP resolution, and correlates them in a 
simple but effective way, playing on the scalar iteration parameter. Therefore, 
our method only require few distances computation, so geometry pre-processing or 
offline optimization are not necessary to remain time competitive. We demonstrate 
that the optimizer is 
time-competitive comparing to random shortcut and proposes better quality paths 
for high-DOF robots, removing unnecessary DOF motions. Our optimizer also manages 
to reduce a local detour in a long path while random shortcut methods will mostly 
fail.

FUTURE WORK


\bibliographystyle{tADR} % plain, alpha, abbr, unsrt
\bibliography{paper}

\end{document}
